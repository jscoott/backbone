var fs = require("fs");
var path = require("path");
var minimatch = require("minimatch");

function findBase(pattern) {
  return pattern.replace(/[*?].*$/, "").replace(/[^/]*$/, "");
}

exports.globSync = function(pattern, options) {
  var files = [];

  // Normalize pattern to absolute path
  var fullPattern = path.resolve(pattern);
  // Determine deepest level non-wildcard path on absolute pattern
  var fullBase = findBase(fullPattern);
  // Determine deepest level non-wildcard on original pattern
  var base = findBase(pattern);

  // If no options specified, default to empty object
  options = options || {};

  function recurseDirectory(root) {
    // Iterate over all found files in the directory
    fs.readdirSync(root).forEach(function(file) {
      // Ensure file path is absolute
      file = path.join(root, file);

      // Strip off the fullBase path and join the original base for minimatch
      // testing later on.
      var normalize = base + file.slice(fullBase.length);

      // Recurse if found a new directory
      if (fs.statSync(file).isDirectory()) {
        // Need to add a trailing slash for directories
        files.push(normalize + "/");

        recurseDirectory(file);
      } else {
        // Add to files array to test 
        files.push(normalize);
      }
    });
  }

  // Add the folder to start from
  files.push(base);

  // Start recursing from the root
  recurseDirectory(fullBase);

  // Use @isaacs minimatch library to create a match of all the globs
  return minimatch.match(files, pattern, options);
};
